// Copyright 2024 Google LLC

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ISEKAI_HOST_FALCON_RUE_STATE_MANAGER_H_
#define ISEKAI_HOST_FALCON_RUE_STATE_MANAGER_H_

#include <cstddef>
#include <list>
#include <utility>
#include <vector>

#include "absl/base/thread_annotations.h"
#include "absl/container/flat_hash_map.h"
#include "absl/log/check.h"
#include "absl/log/log.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/synchronization/mutex.h"
#include "absl/time/clock.h"
#include "absl/time/time.h"
#include "isekai/host/falcon/rue/algorithm/connection_state.h"
#include "isekai/host/falcon/rue/algorithm/dram_state_manager.h"
#include "isekai/host/falcon/rue/algorithm/swift.h"
#include "isekai/host/falcon/rue/util.h"

namespace isekai {
namespace rue {

// Interface used by SwRueEngine to manage RUE state for connections.
class StateManagerInterface {
 public:
  virtual ~StateManagerInterface() = default;
  virtual absl::StatusOr<int> Allocate(int connection_id, bool reallocate) = 0;
  virtual absl::Status Deallocate(int connection_id) = 0;
};

// While SwRue is run in stateless mode, the callback functions
// (Allocate/Deallocate) invoked by SwRueEngine do not need to do anything.
class NoOpStateManager : public StateManagerInterface {
 public:
  NoOpStateManager() = default;
  absl::StatusOr<int> Allocate(int connection_id, bool reallocate) override {
    return connection_id;
  }
  absl::Status Deallocate(int connection_id) override {
    return absl::OkStatus();
  }
};

// This class is thread-safe.
// The assumption is that Allocate()/Deallocate() are called by the "slow-path",
// i.e., control path when creating or destroying a connection.
// GetRawStateForEvent is called by the "fast-path", i.e., thread processing RUE
// Events generated by the hardware.
template <typename EventT>
class StateManager
    : public DramStateManagerInterface<StateManager<EventT>, EventT>,
      public StateManagerInterface {
 public:
  //
  // equal to transaction timeout + time for RUE to wrap around in the mailbox.
  static constexpr absl::Duration kDeallocatedToFreeThreshold =
      absl::Seconds(5);

  explicit StateManager(size_t max_connections);

  // Allocates an entry in the state_table for the given connection_id and
  // returns the index allocated. If the reallocate flag is set, the state
  // manager will deallocate the previous entry (if one exists) for this
  // connection id and allocate a fresh entry.
  absl::StatusOr<int> Allocate(int connection_id, bool reallocate)
      ABSL_LOCKS_EXCLUDED(lock_) override;

  // Deallocates the entry corresponding to the given connection_id.
  absl::Status Deallocate(int connection_id)
      ABSL_LOCKS_EXCLUDED(lock_) override;

  // Looks up the offset in the state_table and returns the raw pointer to the
  // state entry. Since StateManager is a DramStateManagerInterface, callers
  // will use the GetStateForEvent method which internally calls this function.
  void* GetRawStateForEvent(const EventT& event);

 private:
  // Protects cid_index_, free_list_, deallocated_list_ from concurrent access.
  absl::Mutex lock_;

  // A static table storing all connection state.
  std::vector<isekai::rue::ConnectionState<EventT>> state_table_;
  const size_t max_connections_mask_;

  //
  // performance during hitless restart transfer.
  // Stores the mapping of connection_id to allocated state index.
  absl::flat_hash_map<int, int> cid_index_ ABSL_GUARDED_BY(lock_);
  // List of all indices in the state_table that are currently free.
  std::list<int> free_list_ ABSL_GUARDED_BY(lock_);
  // List of indices that were recently deallocated, and will be moved to
  std::list<std::pair<int, absl::Time>> deallocated_list_
      ABSL_GUARDED_BY(lock_);
};

template <typename EventT>
StateManager<EventT>::StateManager(size_t max_connections)
    : max_connections_mask_(max_connections - 1) {
  CHECK_EQ((max_connections & (max_connections - 1)), 0)  // Crash OK
      << "max_connections must be a power of 2.";
  state_table_.resize(max_connections);
  // Append all entries in the free_list.
  for (int i = 0; i < max_connections; ++i) {
    free_list_.push_back(i);
  }
}

template <typename EventT>
absl::StatusOr<int> StateManager<EventT>::Allocate(int connection_id,
                                                   bool reallocate) {
  // Ensure no other thread modifies cid_index_, free_list, deallocated_list_.
  absl::WriterMutexLock wl(&lock_);

  // If the connection_id is already associated with a state entry, the given
  // connection_id being recreated. We must release the previous entry in the
  // state table, and assign a new one if the reallocate flag is set.
  auto it = cid_index_.find(connection_id);
  if (it != cid_index_.end()) {
    if (reallocate) {
      LOG(WARNING) << "SW-RUE re-allocating state for cid: " << connection_id;
      // Deallocate the state_table_ entry corresponding to this connection.
      deallocated_list_.push_back({/*index=*/it->second, absl::Now()});
      cid_index_.erase(it);
    } else {
      return it->second;
    }
  }

  // Move entries from deallocated to free list if sufficient time has elapsed.
  auto now = absl::Now();
  while (!deallocated_list_.empty()) {
    auto [index, time] = deallocated_list_.front();
    if ((now - time) > kDeallocatedToFreeThreshold) {
      free_list_.push_front(index);
      deallocated_list_.pop_front();
    } else {
      // We can break early as the list is maintained in FIFO order, so all
      // other entries are below the time threshold.
      break;
    }
  }

  // Return the first entry in the free_list, and update cid_index mapping.
  if (free_list_.empty()) {
    return absl::ResourceExhaustedError(
        "Insufficient entries in the state_table.");
  }
  int index = free_list_.front();
  cid_index_[connection_id] = index;
  free_list_.pop_front();
  return index;
}

template <typename EventT>
absl::Status StateManager<EventT>::Deallocate(int connection_id) {
  // Ensure no other thread modifies cid_index_ and deallocated_list_.
  absl::WriterMutexLock wl(&lock_);

  // Remove the entry if it exists in the state_table.
  auto it = cid_index_.find(connection_id);
  if (it == cid_index_.end()) {
    return absl::NotFoundError("Connection ID does not have state allocated.");
  }
  deallocated_list_.push_back({/*index=*/it->second, absl::Now()});
  cid_index_.erase(it);
  return absl::OkStatus();
}

// This function is called only by the SW-RUE Event processing thread which
// reads a single element of the state_table_ vector, and the vector is not
// modified after construction. Hence it is safe to access the element without
// any locks.
template <typename EventT>
void* StateManager<EventT>::GetRawStateForEvent(const EventT& event) {
  using ResponseT = typename falcon_rue::GetResponseTypeForEvent<EventT>::Type;
  auto idx = Swift<EventT, ResponseT>::GetStateTableIndex(event.base_delay);
  // During prefetching by the SW RUE driver, there is a chance that the event
  // is not ready yet; we perform a blind prefetch. A malformed event may not
  // have a valid base_delay, hence the following mask.
  idx &= max_connections_mask_;
  return &state_table_[idx];
}

}  // namespace rue
}  // namespace isekai

#endif  // ISEKAI_HOST_FALCON_RUE_STATE_MANAGER_H_
