// Copyright 2024 Google LLC

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ISEKAI_HOST_FALCON_RUE_FORMAT_GEN2_H_
#define ISEKAI_HOST_FALCON_RUE_FORMAT_GEN2_H_

#include <bitset>
#include <cstdint>
#include <sstream>
#include <string>

#include "absl/base/optimization.h"
#include "isekai/host/falcon/falcon.h"
#include "isekai/host/falcon/rue/bits.h"

namespace falcon_rue {

struct __attribute__((packed)) Event_Gen2 {
  // cid
  uint32_t connection_id : kConnectionIdBits;
  // event_type
  falcon::RueEventType event_type : kEventTypeBits;
  // t1
  uint32_t timestamp_1 : kTimeBits;
  // t2
  uint32_t timestamp_2 : kTimeBits;
  // t3
  uint32_t timestamp_3 : kTimeBits;
  // t4
  uint32_t timestamp_4 : kTimeBits;
  // global_rx_req_buf_level
  uint8_t rx_buffer_level : kRxBufferLevelBits;
  // Set if the event was generated by an EACK packet.
  bool eack : 1;
  // nack_code
  falcon::NackCode nack_code : kNackCodeBits;
  // ===== 16 byte boundary =====
  // forward_hops
  uint8_t forward_hops : kForwardHopsBits;
  // retx_count
  uint8_t retransmit_count : kGen2RetransmitCountBits;
  // retx_reason
  falcon::RetransmitReason retransmit_reason : kRetransmitReasonBits;
  // Set if a drop is detected based on the received bitmap in EACK packet.
  bool eack_drop : 1;
  // eack_own bits
  uint8_t eack_own : kEackOwnBits;
  // cc_meta
  uint32_t cc_metadata : kGen2CcMetadataBits;
  // per_host_target_occupancy_buffer_level (part of cc_meta but separated out).

  uint8_t per_host_target_occupancy_buffer_level
      : kPerHostTargetOccupancyBufferLevelBits;

  // fcwnd_frac (10b) and fcwnd (11b) concatenated
  uint32_t fabric_congestion_window : kFabricCongestionWindowBits;
  // ncwnd_frac (10b) and ncwnd (11b) concatenated
  uint32_t nic_congestion_window : kGen2NicCongestionWindowBits;
  bool is_ipv4 : 1;
  bool multipath_enable : 1;
  // flow_label from ipv6 header or udp header src_port for ipv4.
  uint32_t flow_label : kFlowLabelBits;
  // cc_opaque
  uint32_t cc_opaque : kGen2CcOpaqueBits;
  // ===== 16 byte boundary =====
  // window_guard
  uint32_t fabric_window_time_marker : kTimeBits;
  // ncwnd_guard
  uint32_t nic_window_time_marker : kTimeBits;
  // delay_base
  uint32_t base_delay : kTimeBits;
  // delay_state
  uint32_t delay_state : kTimeBits;
  // plb_state
  uint32_t plb_state : kPlbStateBits;
  // delay_sel
  falcon::DelaySelect delay_select : kDelaySelectBits;
  // event_q_sel
  uint8_t event_queue_select : kEventQueueSelectBits;
  uint8_t reserved_0 : 4;  // For future expansion of event queues if required.
  // ===== 16 byte boundary =====
  // smoothed_rtt
  uint32_t rtt_state : kTimeBits;
  // ecn accumulated
  uint16_t ecn_accumulated : kEcnAccumulatedBits;
  // num_acked
  uint16_t num_packets_acked : kNumPacketsAckedBits;
  // csig
  bool csig_enable : 1;
  uint16_t csig : kCsigBits;
  // conn_queue_count
  uint16_t conn_queue_count : kConnectionQueueCountBits;
  uint64_t reserved_1 : 48;
  // gen
  uint8_t gen_bit : 1;

  std::string ToString() const {
    std::ostringstream stream;
    stream << "Gen_2 Event: " << "\n---begin---"
           << "\n  connection_id   : " << connection_id
           << "\n  event_type      : "
           << falcon::RueEventTypeToString(event_type)
           << "\n  timestamp_1     : " << timestamp_1
           << "\n  timestamp_2     : " << timestamp_2
           << "\n  timestamp_3     : " << timestamp_3
           << "\n  timestamp_4     : " << timestamp_4
           << "\n  rx_buffer_level : " << static_cast<int>(rx_buffer_level)
           << "\n  eack_bit        : " << static_cast<int>(eack)
           << "\n  nack_code       : " << falcon::NackCodeToString(nack_code)
           << "\n  forward_hops    : " << static_cast<int>(forward_hops)
           << "\n  retx_count      : " << static_cast<int>(retransmit_count)
           << "\n  retx_reason     : "
           << falcon::RetransmitReasonToString(retransmit_reason)
           << "\n  eack_drop_bit   : " << static_cast<int>(eack_drop)
           << "\n  eack_own_bits   : " << std::bitset<kEackOwnBits>(eack_own)
           << "\n  cc_metadata     : " << cc_metadata
           << "\n  per_host_target_occupancy_buffer_level : "
           << static_cast<unsigned int>(per_host_target_occupancy_buffer_level)
           << "\n  fabric_cwnd     : " << fabric_congestion_window
           << "\n  nic_cwnd        : " << nic_congestion_window
           << "\n  is_ipv4         : " << is_ipv4
           << "\n  multipath_en    : " << multipath_enable
           << "\n  flow_label      : " << flow_label
           << "\n  cc_opaque       : " << cc_opaque
           << "\n  fcwnd_guard     : " << fabric_window_time_marker
           << "\n  ncwnd_guard     : " << nic_window_time_marker
           << "\n  delay_base      : " << base_delay
           << "\n  delay_state     : " << delay_state
           << "\n  plb_state       : " << plb_state << "\n  delay_select    : "
           << falcon::DelaySelectToString(delay_select)
           << "\n  event_q_select  : " << static_cast<int>(event_queue_select)
           << "\n  reserved_0      : " << static_cast<int>(reserved_0)
           << "\n  rtt_state       : " << rtt_state
           << "\n  ecn_accumulated : " << static_cast<int>(ecn_accumulated)
           << "\n  num_acked       : " << num_packets_acked
           << "\n  csig_enable     : " << csig_enable
           << "\n  csig            : " << static_cast<int>(csig)
           << "\n  conn_queue_cnt  : " << static_cast<int>(conn_queue_count)
           << "\n  reserved_1      : " << static_cast<uint64_t>(reserved_1)
           << "\n  gen_bit         : " << static_cast<int>(gen_bit)
           << "\n----end----";
    return stream.str();
  }
};

struct __attribute__((packed)) Response_Gen2 {
  // cid
  uint32_t connection_id : kConnectionIdBits;
  // fcwnd_frac and fcwnd concatenated
  uint32_t fabric_congestion_window : kFabricCongestionWindowBits;
  // fipg
  uint32_t inter_packet_gap : kInterPacketGapBits;
  // ncwnd_frac and ncwnd concatenated
  uint32_t nic_congestion_window : kGen2NicCongestionWindowBits;
  // nipg
  uint32_t nic_inter_packet_gap : kInterPacketGapBits;
  // cc_meta
  uint32_t cc_metadata : kCcMetadataBits;
  // ===== 16 byte boundary =====
  // Hawees TX isolation parameters.
  uint8_t alpha_request : kPerConnectionBackpressureAlphaBits;
  uint8_t alpha_response : kPerConnectionBackpressureAlphaBits;
  // window_guard
  uint32_t fabric_window_time_marker : kTimeBits;
  // ncwnd_guard
  uint32_t nic_window_time_marker : kTimeBits;
  // delay_base
  uint32_t base_delay : kTimeBits;
  // delay_state
  uint32_t delay_state : kTimeBits;
  // plb_state
  uint32_t plb_state : kPlbStateBits;
  // cc_opaque
  uint32_t cc_opaque : kGen2CcOpaqueBits;
  // delay_sel
  falcon::DelaySelect delay_select : kDelaySelectBits;
  // ar_rate
  uint8_t ar_rate : kArRateBits;
  // smoothed_rtt
  uint32_t rtt_state : kTimeBits;
  // flow_label[3:0]
  uint32_t flow_label_1 : kFlowLabelBits;
  uint32_t flow_label_2 : kFlowLabelBits;
  uint32_t flow_label_3 : kFlowLabelBits;
  uint32_t flow_label_4 : kFlowLabelBits;
  // flow_label_weight[3:0]
  uint8_t flow_label_1_weight : kFlowLabelWeightBits;
  uint8_t flow_label_2_weight : kFlowLabelWeightBits;
  uint8_t flow_label_3_weight : kFlowLabelWeightBits;
  uint8_t flow_label_4_weight : kFlowLabelWeightBits;
  // flow_label_valid[3:0]
  bool flow_label_1_valid : 1;
  bool flow_label_2_valid : 1;
  bool flow_label_3_valid : 1;
  bool flow_label_4_valid : 1;
  // wrr_restart_round
  bool wrr_restart_round : 1;
  // flow_id
  uint8_t flow_id : kFlowIdBits;
  // csig
  bool csig_enable : 1;
  uint8_t csig_select : kCsigSelectBits;
  // retx_to
  uint32_t retransmit_timeout : kTimeBits;
  // event_q_sel
  uint8_t event_queue_select : kEventQueueSelectBits;
  uint64_t padding_0 : 11;
  uint64_t padding_1 : 64;

  std::string ToString() const {
    std::ostringstream stream;
    stream << "Gen_2 Response: " << "\n---begin---"
           << "\n  connection_id   : " << connection_id
           << "\n  fabric_cwnd     : " << fabric_congestion_window
           << "\n  fabric_ipg      : " << inter_packet_gap
           << "\n  nic_cwnd        : " << nic_congestion_window
           << "\n  nic_ipg         : " << nic_inter_packet_gap
           << "\n  cc_metadata     : " << cc_metadata
           << "\n  alpha_request   : " << static_cast<int>(alpha_request)
           << "\n  alpha_response  : " << static_cast<int>(alpha_response)
           << "\n  fcwnd_guard     : " << fabric_window_time_marker
           << "\n  ncwnd_guard     : " << nic_window_time_marker
           << "\n  delay_base      : " << base_delay
           << "\n  delay_state     : " << delay_state
           << "\n  plb_state       : " << plb_state
           << "\n  cc_opaque       : " << cc_opaque << "\n  delay_select    : "
           << falcon::DelaySelectToString(delay_select)
           << "\n  ar_rate         : " << static_cast<int>(ar_rate)
           << "\n  rtt_state       : " << rtt_state
           << "\n  flow_label_1    : " << flow_label_1
           << "\n  flow_label_2    : " << flow_label_2
           << "\n  flow_label_3    : " << flow_label_3
           << "\n  flow_label_4    : " << flow_label_4
           << "\n  flow_weight_1   : " << static_cast<int>(flow_label_1_weight)
           << "\n  flow_weight_2   : " << static_cast<int>(flow_label_2_weight)
           << "\n  flow_weight_3   : " << static_cast<int>(flow_label_3_weight)
           << "\n  flow_weight_4   : " << static_cast<int>(flow_label_4_weight)
           << "\n  flow_1_valid    : " << flow_label_1_valid
           << "\n  flow_2_valid    : " << flow_label_2_valid
           << "\n  flow_3_valid    : " << flow_label_3_valid
           << "\n  flow_4_valid    : " << flow_label_4_valid
           << "\n  wrr_restart     : " << wrr_restart_round
           << "\n  flow_id         : " << static_cast<int>(flow_id)
           << "\n  csig_enable     : " << csig_enable
           << "\n  csig_select     : " << static_cast<int>(csig_select)
           << "\n  retx_timeout    : " << retransmit_timeout
           << "\n  event_q_select  : " << static_cast<int>(event_queue_select)
           << "\n  padding_0       : " << static_cast<uint64_t>(padding_0)
           << "\n  padding_1       : " << static_cast<uint64_t>(padding_1)
           << "\n----end----";
    return stream.str();
  }
};

static_assert(sizeof(Event_Gen2) == ABSL_CACHELINE_SIZE,
              "Event is not one cache line :(");
static_assert(sizeof(Response_Gen2) == ABSL_CACHELINE_SIZE,
              "Response is not one cache line :(");

}  // namespace falcon_rue

#endif  // ISEKAI_HOST_FALCON_RUE_FORMAT_GEN2_H_
